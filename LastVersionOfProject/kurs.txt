Напомним основные определения:

Две вершины ( u и v ) ориентированного графа называют сильно связными, если существует путь из 
u в v
и существует путь из v в u.

Ориентированный граф называется сильно связным, если любые две его вершины сильно связны. 
Инвертированием ориентированного графа назовем процедуру, в ходе которой поменяем направление каждого ребра на противоположное. (При использовании матрицы смежности под 
инвертированием понимается транспонированная матрица).

Отношение сильной связности - это отношение эквивалентности.
Тоесть выполняются 3 отношения:
1)Рефлексивность: ?v v>v
2)Симметричность: ?v ?u v>u=>u>v
3)Транзитивность:?v ?u ?t v>u ?u>t=>v>t

Тогда, компонентой сильной связности называется класс эквивалентности множества вершин ориентированного графа относительно отношения сильной связности.

Итак, наша задача найти все такие классы эквивалентности.

Алгоритм Косарайю

Метод Косарайю идея состоит в том, что у исходного графа и его инвертирования совпадают компоненты сильной связности (т.к они по сути являются циклами).

Пусть дан ориентированный граф G = (V,E). 

G' = (V, E') — граф, полученный инвертированием исходного графа G

Теперь выполним поиск в глубину на G'. Будем помечать время входа и время выхода (in/out). Заведем дополнительно массив вершин verticles. В него добавим все вершины в порядке увеличения времени выхода.

Теперь запустим обход в глубинку на исходном графе, но каждый раз выбирая для обхода ещё не посещенную вершину с максимальным индексом в массиве verticles. Все вершины, посещенные в ходе одной итерации dfs, образуют компоненту связности (помечены цветами).

Вместо заключения:

Заметим, что если граф представлен графом смежности, то нам не требует инвертированный граф, мы можем работать на том же графе. Иначе нам требует O(V+E), чтобы получить инвертированный граф и ещё V+E памяти для хранения инвертированного графа.

Тем не менее, основная часть алгоритма состоит из двух обходов DFS. Каждый работает пропорционально V+E для разреженных графов и V^2 для насыщенных графов. Также нам требуется V памяти для хранения массива вершин

Для того ,чтобы получить вершины в массиве verticles в порядке убывания 
 необходимо его отсортировать, в алгоритме будем использовать 2 сортировки в 2 разных версиях программ.

В алгоритме будем использовать вместо матрицы смежности, массив ребер, что позволит сократить память. 